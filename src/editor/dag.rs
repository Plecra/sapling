//! Code for an editable, undoable forest of syntax trees.

use crate::arena::Arena;
use crate::ast;
use crate::ast::{Ast, AstClass};

use crate::core::{Direction, Path, Side};

/// The two possible locations where an edit could cause nodes to be replaced
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum EditLocation {
    /// The edit caused the cursor to be replaced
    Cursor = 0,
    /// The edit caused the parent to be replaced
    Parent = 1,
}

impl EditLocation {
    /// How many steps above the cursor was the edit made
    #[inline]
    fn steps_above_cursor(self) -> usize {
        self as usize
    }
}

/// An enum that's returned when any of the 'edit' methods in [`Dag`] are successful.
#[allow(missing_docs)]
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum EditSuccess<C: AstClass> {
    Undo,
    Redo,
    Move(Direction),
    Replace(C),
    InsertChild(C),
    InsertNextToCursor { side: Side, class: C },
    Delete { name: String },
}

impl<C: AstClass> EditSuccess<C> {
    /// Writes an info message of a successful action using `info!`
    fn log_message(self) {
        match self {
            EditSuccess::Undo => log::info!("Undoing one change"),
            EditSuccess::Redo => log::info!("Redoing one change"),
            EditSuccess::Move(Direction::Up) => log::info!("Moving up the tree"),
            EditSuccess::Move(Direction::Down) => log::info!("Moving down the tree"),
            EditSuccess::Move(Direction::Prev) => log::info!("Moving to previous child"),
            EditSuccess::Move(Direction::Next) => log::info!("Moving to next child"),
            EditSuccess::Replace(class) => {
                log::info!("Replacing with '{}'/{}", class.to_char(), class.name())
            }
            EditSuccess::InsertChild(class) => {
                log::info!(
                    "Inserting '{}'/{} as new child",
                    class.to_char(),
                    class.name()
                )
            }
            EditSuccess::InsertNextToCursor { side, class } => log::info!(
                "Inserting '{}'/{} {} the cursor",
                class.to_char(),
                class.name(),
                side.relational_word()
            ),
            EditSuccess::Delete { name } => log::info!("Deleting {}", name),
        }
    }
}

/// An error that represents an error in any of the 'edit' methods in [`Dag`].
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub enum EditErr<C: AstClass> {
    /* MOVEMENT ERRORS */
    /// Trying to move to the child of a node with no children
    MoveToNonexistentChild,
    /// Trying to move to the parent of the root
    MoveToParentOfRoot,
    /// Trying to move to a sibling that doesn't exist
    MoveToNonexistentSibling,
    /// Trying to move to a sibling of the root
    MoveToSiblingOfRoot,

    /* EDITING ERRORS */
    /// Trying to undo the earliest change
    NoChangesToUndo,
    /// Trying to redo the latest change
    NoChangesToRedo,
    /// The user typed a char that doesn't correspond to any node
    CharNotANode(char),
    /// Trying to insert a node that cannot be root node
    CannotBeRoot(C),
    /// Trying to insert a node that cannot be a child of the cursor
    CannotBeChild {
        /// The class representing the disallowed child type
        class: C,
        /// The [`display_name`](Ast::display_name) of the parent node
        parent_name: String,
    },
    /// An error was generated by the Ast code when trying to insert a node
    InsertError(ast::InsertError),
    /// An error was generated by the Ast code when trying to delete a node
    DeleteError(ast::DeleteError),
    /// Trying to add a sibling to the root
    AddSiblingToRoot,
    /// Trying to delete the root
    DeletingRoot,
}

impl<C: AstClass> EditErr<C> {
    /// Writes an warning message of the encountered error using either `warn!` or `error!`,
    /// depending on the severity of the error
    fn log_message(self) {
        match self {
            EditErr::MoveToNonexistentChild => {
                log::warn!("Can't move down if the cursor has no children.")
            }
            EditErr::MoveToNonexistentSibling => {
                log::warn!("Can't move to a non-existent sibling.")
            }
            EditErr::MoveToParentOfRoot => log::warn!("Can't move to the parent of the root."),
            EditErr::MoveToSiblingOfRoot => log::warn!("Can't move to a sibling of the root."),
            EditErr::NoChangesToUndo => log::warn!("No changes to undo."),
            EditErr::NoChangesToRedo => log::warn!("No changes to redo."),
            EditErr::InsertError(e) => log::warn!("{}", e),
            EditErr::DeleteError(e) => log::warn!("{}", e),
            EditErr::CharNotANode(c) => log::warn!("'{}' doesn't correspond to any node type.", c),
            EditErr::CannotBeRoot(c) => {
                log::warn!("'{}' cannot be root", c.name())
            }
            EditErr::CannotBeChild { class, parent_name } => {
                log::warn!("'{}' cannot be a child of {}", class.name(), parent_name)
            }
            EditErr::AddSiblingToRoot => log::warn!("Can't add siblings to the root."),
            EditErr::DeletingRoot => log::warn!("Can't delete the root."),
        }
    }
}

impl<C: AstClass> From<ast::InsertError> for EditErr<C> {
    fn from(e: ast::InsertError) -> EditErr<C> {
        EditErr::InsertError(e)
    }
}

impl<C: AstClass> From<ast::DeleteError> for EditErr<C> {
    fn from(e: ast::DeleteError) -> EditErr<C> {
        EditErr::DeleteError(e)
    }
}

/// An alias for [`Result`] that is the return type of all of [`Dag`]'s edit methods.
pub type EditResult<C> = Result<EditSuccess<C>, EditErr<C>>;

/// A trait-extension that provides a convenient way convert [`EditResult`]s into log messages.
pub trait LogMessage {
    /// Log the current result's message to the appropriate log channel.
    fn log_message(self);
}

impl<C: AstClass> LogMessage for EditResult<C> {
    /// Consumes this `EditResult` and logs an appropriate summary report (using `info!` for
    /// [`EditSuccess`]es and `warn!` or `error!` for [`EditErr`]s).
    fn log_message(self) {
        match self {
            Ok(ok) => ok.log_message(),
            Err(err) => err.log_message(),
        }
    }
}

/// A specification of things which can be inserted into a syntax tree
#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
pub enum Insertable {
    /// Insert the node given by a certain [`char`] some number of times
    CountedNode(usize, char),
}

impl std::fmt::Display for Insertable {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Insertable::CountedNode(count, c) => write!(f, "{}{}", count, c),
        }
    }
}

/// A datastructure that stores the history of a tree as a Dag (Directed Acyclic Graph) of
/// **immutable** nodes.
///
/// This means that every node that has ever been created exists somewhere in the Dag, and when
/// changes are made, every ancestor of that node is cloned until the root is reached and that
/// root becomes the new 'current' root.  This is very similar to the way Git handles commits -
/// each node is like a file/directory and each root is a commit.
///
/// Therefore, moving back through the history is as simple as reading a different root node from
/// the `roots` vector, and following its descendants through the Dag of nodes.
pub struct Dag<'arena, Node: Ast<'arena>> {
    /// The arena in which all the `Node`s will be stored
    arena: &'arena Arena<Node>,
    /// A [`Vec`] containing a reference to the root node at every edit in the undo history.  This
    /// is required to always have length at least one.
    root_history: Vec<(&'arena Node, Path)>,
    /// An index into [`root_history`](Dag::root_history) of the current edit.  This is required to
    /// be in `0..root_history.len()`.
    history_index: usize,
    current_cursor_path: Path,
}

impl<'arena, Node: Ast<'arena>> Dag<'arena, Node> {
    /// Builds a new `Dag`, given the tree it should contain
    pub fn new(arena: &'arena Arena<Node>, root: &'arena Node, cursor_path: Path) -> Self {
        Dag {
            arena,
            root_history: vec![(root, cursor_path.clone())],
            history_index: 0,
            current_cursor_path: cursor_path,
        }
    }

    /* NAVIGATION METHODS */

    /// Returns a reference to the node that is currently the root of the AST.
    pub fn root(&self) -> &'arena Node {
        // This indexing shouldn't panic because we require that `self.history_index` is a valid
        // index into `self.root_history`, and `self.root_history` has at least one element
        self.root_history[self.history_index].0
    }

    /// Returns the cursor node and its direct parent (if such a parent exists)
    pub fn cursor_and_parent(&self) -> (&'arena Node, Option<&'arena Node>) {
        self.current_cursor_path.cursor_and_parent(self.root())
    }

    /// Returns a reference to the node that is currently under the cursor.
    pub fn cursor(&self) -> &'arena Node {
        self.current_cursor_path.cursor(self.root())
    }

    /// Move the cursor in a given direction across the tree.  Returns [`Some`] error string if an
    /// error is found, or [`None`] if the movement was possible.
    pub fn move_cursor(&mut self, direction: Direction) -> EditResult<Node::Class> {
        let (current_cursor, cursor_parent) = self.cursor_and_parent();
        match direction {
            Direction::Down => {
                if current_cursor.children().is_empty() {
                    return Err(EditErr::MoveToNonexistentChild);
                }
                self.current_cursor_path.push(0);
            }
            Direction::Up => {
                if self.current_cursor_path.is_root() {
                    return Err(EditErr::MoveToParentOfRoot);
                }
                self.current_cursor_path.pop();
            }
            Direction::Prev => {
                let index = self
                    .current_cursor_path
                    .last_mut()
                    .ok_or(EditErr::MoveToSiblingOfRoot)?;
                if *index == 0 {
                    return Err(EditErr::MoveToNonexistentSibling);
                }
                *index -= 1;
            }
            Direction::Next => {
                let last_index = self
                    .current_cursor_path
                    .last_mut()
                    .ok_or(EditErr::MoveToSiblingOfRoot)?;
                // We can unwrap here, because the only way for a node to not have a parent is
                // if it's the root.  And if the cursor is at the root, then the `if let` would
                // have failed and this code would not be run.
                if *last_index + 1 >= cursor_parent.unwrap().children().len() {
                    return Err(EditErr::MoveToNonexistentSibling);
                }
                *last_index += 1;
            }
        }
        Ok(EditSuccess::Move(direction))
    }

    /* HISTORY METHODS */

    /// Move one step back in the tree history
    pub fn undo(&mut self) -> EditResult<Node::Class> {
        log::trace!("Performing undo.");
        // Early return if there are no changes to undo
        if self.history_index == 0 {
            return Err(EditErr::NoChangesToUndo);
        }
        // Move the history index back by one to perform the undo
        self.history_index -= 1;
        // Follow the behaviour of other text editors and update the location of the cursor
        // with its location in the snapshot we are going forward to
        self.current_cursor_path
            .clone_from(&self.root_history[self.history_index].1);
        log::debug!("Setting cursor path to {:?}", self.current_cursor_path);
        Ok(EditSuccess::Undo)
    }

    /// Move one step forward in the tree history
    pub fn redo(&mut self) -> EditResult<Node::Class> {
        log::trace!("Performing redo.");
        // Early return if there are no changes to redo
        if self.history_index >= self.root_history.len() - 1 {
            return Err(EditErr::NoChangesToRedo);
        }
        // Move the history index forward by one to perform the redo
        self.history_index += 1;
        // Follow the behaviour of other text editors and update the location of the cursor
        // with its location in the snapshot we are going back to
        self.current_cursor_path
            .clone_from(&self.root_history[self.history_index].1);
        log::debug!("Setting cursor path to {:?}", self.current_cursor_path);
        Ok(EditSuccess::Redo)
    }

    /* EDITING METHODS */

    fn perform_edit(
        &mut self,
        mut edit_func: impl FnMut(
            // The `Dag` being edited
            &mut Self,
            // The parent and the cursor's child index (or `None` if the cursor is at the root)
            Option<(&'arena Node, usize)>,
            // A reference to the node under the cursor
            &'arena Node,
        ) -> Result<
            (Node, EditLocation, EditSuccess<Node::Class>),
            EditErr<Node::Class>,
        >,
    ) -> EditResult<Node::Class> {
        // Generate a vec of pointers to the nodes that we will have to clone.  We have to store
        // this as a vec because the iterator that produces them (cursor_path::NodeIter) can only
        // yield values from the root downwards, whereas we need the nodes in the opposite order.
        let nodes_to_clone: Vec<&Node> = self.current_cursor_path.node_iter(self.root()).collect();
        let old_cursor_path: Path = self.current_cursor_path.clone();

        // Unwrap is safe because `nodes_to_clone` must always contain at least the root
        let mut reverse_node_iter = nodes_to_clone.iter().copied().rev();
        let cursor = reverse_node_iter.next().unwrap();
        // Unwrapping in the closure is safe, because if the cursor does have a parent, then the
        // cursor_path must have at least one element
        let parent_and_index = reverse_node_iter
            .next()
            .map(|node| (node, old_cursor_path.last().unwrap()));

        /* PERFORM THE EDIT */

        let (new_node, edit_location, success) = edit_func(self, parent_and_index, cursor)?;
        let steps_above_cursor = edit_location.steps_above_cursor();

        /* CLONE ALL THE PARENT NODES TO GET A NEW ROOT */

        // Because AST nodes are immutable, we make changes to nodes by entirely cloning the path
        // down to the node under the cursor.  We do this starting at the node under the cursor and
        // work our way up parent by parent until we reach the root of the tree.  At that point,
        // this node becomes the root of the new tree.
        let mut node = self.arena.alloc(new_node);
        // Iterate backwards over the child indices and the nodes, whilst cloning the tree and
        // replacing the correct child reference to point to the newly created node.
        for (n, child_index) in nodes_to_clone
            .iter()
            .rev()
            .skip(1)
            .zip(old_cursor_path.iter().rev())
            .skip(steps_above_cursor)
        {
            let mut cloned_node = (*n).clone();
            cloned_node.replace_child(*child_index, node);
            node = self.arena.alloc(cloned_node);
        }

        /* UPDATE THE HISTORY */

        // Remove future trees from the history vector so that the currently 'checked-out' tree is
        // the most recent tree in the history.
        while self.history_index < self.root_history.len() - 1 {
            // TODO: Deallocate the tree so that we don't get a 'memory leak'
            self.root_history.pop();
        }
        // At this point, `node` contains a reference to the root of the new tree, so we just add
        // this to the history, along with the cursor path.
        self.root_history
            .push((node, self.current_cursor_path.clone()));
        // Move the history index on by one so that we are pointing at the latest change
        self.history_index = self.root_history.len() - 1;

        /* RETURN SUCCESS */
        Ok(success)
    }

    /// Replaces the current cursor with a node represented by `c`
    pub fn replace_cursor(&mut self, with: Insertable) -> EditResult<Node::Class> {
        let (count, c) = match with {
            Insertable::CountedNode(count, c) => (count, c),
        };
        let class = Node::Class::from_char(c).ok_or(EditErr::CharNotANode(c))?;

        self.perform_edit(
            |_this: &mut Self,
             _parent_and_index: Option<(&'arena Node, usize)>,
             cursor: &'arena Node| {
                // Early return if the `class` can't go in the cursor's location
                match _parent_and_index {
                    Some((parent, cursor_index)) => {
                        if !parent.is_valid_child(cursor_index, class) {
                            return Err(EditErr::CannotBeChild {
                                class,
                                parent_name: _parent_and_index
                                    .map_or("<root>".to_owned(), |(p, _)| p.display_name()),
                            });
                        }
                    }
                    None => {
                        if !cursor.is_valid_root(class) {
                            return Err(EditErr::CannotBeRoot(class));
                        }
                    }
                }

                // Create the node to replace.
                let new_node = Node::from_class(class);
                Ok((new_node, EditLocation::Cursor, EditSuccess::Replace(class)))
            },
        )
    }

    /// Updates the internal state so that the tree now contains `new_node` inserted as the last
    /// child of the selected node.  Also moves the cursor so that the new node is selected.
    pub fn insert_child(&mut self, insertable: Insertable) -> EditResult<Node::Class> {
        let (count, c) = match insertable {
            Insertable::CountedNode(count, c) => (count, c),
        };
        let class = Node::Class::from_char(c).ok_or(EditErr::CharNotANode(c))?;
        self.perform_edit(
            |this: &mut Self,
             _parent_and_index: Option<(&'arena Node, usize)>,
             cursor: &'arena Node| {
                log::debug!("Inserting '{}' as a new child.", c);
                if !cursor.is_valid_child(cursor.children().len(), class) {
                    log::debug!("New node could not be a valid child of the cursor");
                    // Short circuit if `c` couldn't be a valid child of the cursor
                    return Err(EditErr::CannotBeChild {
                        class,
                        parent_name: cursor.display_name(),
                    });
                }
                // Create the node to insert
                let new_node = this.arena.alloc(Node::from_class(class));
                // Clone the node that currently is the cursor, and add the new child to the end of
                // its children.
                let mut cloned_cursor = cursor.clone();
                // Store the new_node's display name before it's consumed by `finish_edit`
                // Add the new child to the children of the cloned cursor
                for _ in 0..count {
                    cloned_cursor.insert_child(
                        new_node,
                        this.arena,
                        cloned_cursor.children().len(),
                    )?;
                }

                // moves the cursor to the newly added child
                this.current_cursor_path.push(cursor.children().len());

                Ok((
                    cloned_cursor,
                    EditLocation::Cursor,
                    EditSuccess::InsertChild(class),
                ))
            },
        )
    }

    /// Updates the internal state so that the tree now contains `new_node` inserted as the first
    /// child of the selected node.  Also moves the cursor so that the new node is selected.
    pub fn insert_next_to_cursor(
        &mut self,
        insertable: Insertable,
        side: Side,
    ) -> EditResult<Node::Class> {
        let (count, c) = match insertable {
            Insertable::CountedNode(count, c) => (count, c),
        };
        let class = Node::Class::from_char(c).ok_or(EditErr::CharNotANode(c))?;

        self.perform_edit(
            |this: &mut Self,
             parent_and_index: Option<(&'arena Node, usize)>,
             _cursor: &'arena Node| {
                // Find (and cache) the parent of the cursor.  If the parent of the cursor doesn't
                // exist, the cursor must be the root and we can't insert a node next to the root.
                let (parent, cursor_index) = parent_and_index.ok_or(EditErr::AddSiblingToRoot)?;

                // Short circuit if not an insertable char
                if !parent.is_valid_child(cursor_index, class) {
                    return Err(EditErr::CannotBeChild {
                        class,
                        parent_name: parent.display_name(),
                    });
                }

                let insert_index = cursor_index
                    + match side {
                        Side::Prev => 0,
                        Side::Next => 1,
                    };
                let mut cloned_parent = parent.clone();
                // Create the new sibling node according to the given class.
                let new_node = this.arena.alloc(Node::from_class(class));
                // Add the new child to the children of the cloned cursor
                cloned_parent.insert_child(new_node, this.arena, insert_index)?;
                // move the cursor to the correct location, we can unwrap it here, because we
                // know we will not insert sibling to root node
                *this.current_cursor_path.last_mut().unwrap() = insert_index;
                // Return the success
                Ok((
                    cloned_parent,
                    EditLocation::Parent,
                    EditSuccess::InsertNextToCursor { side, class },
                ))
            },
        )
    }

    /// Deletes the node underneath the cursor
    pub fn delete_cursor(&mut self) -> EditResult<Node::Class> {
        self.perform_edit(
            |this: &mut Self,
             parent_and_index: Option<(&'arena Node, usize)>,
             cursor: &'arena Node| {
                // Find (and cache) the parent of the cursor.  If the parent of the cursor doesn't
                // exist, the cursor must be the root and we can't delete the root.
                let (parent, cursor_index) = parent_and_index.ok_or(EditErr::DeletingRoot)?;
                // Cache the name of the cursor **before** it gets deleted
                let deleted_node_name = cursor.display_name();

                let mut cloned_parent = parent.clone();
                cloned_parent.delete_child(cursor_index)?;

                let new_parents_child_count = cloned_parent.children().len();
                if new_parents_child_count == 0 {
                    // If we remove the only child of a node then we move the cursor up
                    this.current_cursor_path.pop();
                } else if cursor_index == new_parents_child_count {
                    // If we deleted the last child of a node (and this isn't the last child), we
                    // move the cursor back by one.  We can unwrap here because we know we aren't
                    // removing the root
                    *this.current_cursor_path.last_mut().unwrap() -= 1;
                }

                Ok((
                    cloned_parent,
                    EditLocation::Parent,
                    EditSuccess::Delete {
                        name: deleted_node_name,
                    },
                ))
            },
        )
    }

    /* DISPLAY METHODS */

    /// Build the text representation of the current tree into the given [`String`]
    pub fn write_text(&self, string: &mut String, format: &Node::FormatStyle) {
        self.root().write_text(string, format);
    }

    /// Build and return a [`String`] of the current tree
    pub fn to_text(&self, format: &Node::FormatStyle) -> String {
        let mut s = String::new();
        self.write_text(&mut s, format);
        s
    }
}

#[cfg(test)]
mod tests {
    use super::{Dag, EditErr, EditResult, EditSuccess, Insertable};
    use crate::arena::Arena;
    use crate::ast::json::{Class, Json};
    use crate::ast::test_json::TestJson;
    use crate::core::{Direction, Path, Side};
    use crate::editor::normal_mode::Action;

    trait ExecuteAction {
        fn execute_action(&mut self, action: Action) -> EditResult<Class>;
    }

    impl<'arena> ExecuteAction for Dag<'arena, Json<'arena>> {
        fn execute_action(&mut self, action: Action) -> EditResult<Class> {
            match action {
                Action::Undo => self.undo(),
                Action::Redo => self.redo(),
                Action::MoveCursor(direction) => self.move_cursor(direction),
                Action::Replace(c) => self.replace_cursor(c),
                Action::InsertChild(c) => self.insert_child(c),
                Action::InsertBefore(c) => self.insert_next_to_cursor(c, Side::Prev),
                Action::InsertAfter(c) => self.insert_next_to_cursor(c, Side::Next),
                Action::Delete => self.delete_cursor(),
                Action::Quit => unreachable!(),
            }
        }
    }

    fn run_test_ok(
        start_tree: TestJson,
        start_cursor_location: Path,
        action: Action,
        expected_edit_success: EditSuccess<Class>,
        expected_tree: TestJson,
        expected_cursor_location: Path,
    ) {
        let arena: Arena<Json> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut dag = Dag::new(&arena, root, start_cursor_location);

        assert_eq!(
            Ok(expected_edit_success),
            dag.execute_action(action),
            "Not equal in action result"
        );
        assert_eq!(expected_tree, dag.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location, dag.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    fn run_test_err(
        start_tree: TestJson,
        start_cursor_location: Path,
        action: Action,
        expected_edit_err: EditErr<Class>,
    ) {
        let arena: Arena<Json> = Arena::new();
        let root = start_tree.clone().add_to_arena(&arena);
        let mut dag = Dag::new(&arena, root, start_cursor_location.clone());

        assert_eq!(
            Err(expected_edit_err),
            dag.execute_action(action),
            "Not equal in action result"
        );
        assert_eq!(start_tree, dag.root(), "Not equal in tree.");
        assert_eq!(
            start_cursor_location, dag.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    #[test]
    fn root_insertchild() {
        run_test_ok(
            TestJson::Array(vec![]),
            Path::root(),
            Action::InsertChild(Insertable::CountedNode(1, 'f')),
            EditSuccess::InsertChild(Class::False),
            TestJson::Array(vec![TestJson::False]),
            Path::from_vec(vec![0]),
        );

        // Dag level == 1

        run_test_ok(
            TestJson::Array(vec![TestJson::Array(vec![]), TestJson::True]),
            Path::root(),
            Action::InsertChild(Insertable::CountedNode(1, 'n')),
            EditSuccess::InsertChild(Class::Null),
            TestJson::Array(vec![
                TestJson::Array(vec![]),
                TestJson::True,
                TestJson::Null,
            ]),
            Path::from_vec(vec![2]),
        )
    }

    #[test]
    fn root_insertbefore() {
        run_test_err(
            TestJson::Array(vec![]),
            Path::root(),
            Action::InsertBefore(Insertable::CountedNode(1, 'f')),
            EditErr::AddSiblingToRoot,
        );

        // tree level == 1
        run_test_err(
            TestJson::Array(vec![TestJson::Array(vec![]), TestJson::True]),
            Path::root(),
            Action::InsertBefore(Insertable::CountedNode(1, 'f')),
            EditErr::AddSiblingToRoot,
        );
    }

    #[test]
    fn root_insertafter() {
        run_test_err(
            TestJson::Array(vec![]),
            Path::root(),
            Action::InsertAfter(Insertable::CountedNode(1, 'f')),
            EditErr::AddSiblingToRoot,
        );

        // tree level == 1
        run_test_err(
            TestJson::Array(vec![TestJson::Array(vec![]), TestJson::True]),
            Path::root(),
            Action::InsertAfter(Insertable::CountedNode(1, 'f')),
            EditErr::AddSiblingToRoot,
        );
    }

    #[test]
    fn root_replace() {
        run_test_ok(
            TestJson::Array(vec![]),
            Path::root(),
            Action::Replace(Insertable::CountedNode(1, 'f')),
            EditSuccess::Replace(Class::False),
            TestJson::False,
            Path::root(),
        );

        // Char not a node
        run_test_err(
            TestJson::False,
            Path::root(),
            Action::Replace(Insertable::CountedNode(1, 'm')),
            EditErr::CharNotANode('m'),
        );
        //
        // tree level == 1
        run_test_ok(
            TestJson::Array(vec![TestJson::True, TestJson::Array(vec![])]),
            Path::root(),
            Action::Replace(Insertable::CountedNode(1, 'n')),
            EditSuccess::Replace(Class::Null),
            TestJson::Null,
            Path::root(),
        );
    }

    #[test]
    fn root_delete() {
        run_test_err(
            TestJson::Array(vec![]),
            Path::root(),
            Action::Delete,
            EditErr::DeletingRoot,
        );

        // dag level==1
        run_test_err(
            TestJson::Array(vec![TestJson::Array(vec![]), TestJson::True]),
            Path::root(),
            Action::Delete,
            EditErr::DeletingRoot,
        );
    }

    #[test]
    fn root_movecursor() {
        // move to previous sibling node of root
        run_test_err(
            TestJson::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Prev),
            EditErr::MoveToSiblingOfRoot,
        );
        // move to next sibling node of root
        run_test_err(
            TestJson::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Next),
            EditErr::MoveToSiblingOfRoot,
        );
        // move to parent node of root
        run_test_err(
            TestJson::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Up),
            EditErr::MoveToParentOfRoot,
        );
        // move to nonexistent child node of root
        run_test_err(
            TestJson::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            EditErr::MoveToNonexistentChild,
        );

        // move to nonexistent child node of root
        run_test_err(
            TestJson::Array(vec![]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            EditErr::MoveToNonexistentChild,
        );
        // move to root from child
        run_test_ok(
            TestJson::Array(vec![TestJson::False, TestJson::True]),
            Path::from_vec(vec![1]),
            Action::MoveCursor(Direction::Up),
            EditSuccess::Move(Direction::Up),
            TestJson::Array(vec![TestJson::False, TestJson::True]),
            Path::root(),
        );
    }

    #[test]
    fn root_undo() {
        let start_tree = TestJson::Array(vec![]);
        let start_cursor_location = Path::root();
        let end_tree = TestJson::False;
        let end_cursor_location = Path::root();

        // Initialise the Dag with the `start_tree`
        let arena: Arena<Json> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = Dag::new(&arena, root, start_cursor_location.clone());

        // We start with an empty Json array (`[]`), and we replace it with `false`
        assert_eq!(
            Ok(EditSuccess::Replace(Class::False)),
            editable_tree.execute_action(Action::Replace(Insertable::CountedNode(1, 'f'))),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Undo the change
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            start_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        //  Dag level == 1
        let start_tree = TestJson::Array(vec![TestJson::Null, TestJson::True, TestJson::False]);
        let start_cursor_location = Path::root();
        // We move the cursor so we expect the cursor to move but no change to occur to the tree
        let end_cursor_location = Path::from_vec(vec![0]);

        let arena: Arena<Json> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = Dag::new(&arena, root, start_cursor_location);

        assert_eq!(
            Ok(EditSuccess::Move(Direction::Down)),
            editable_tree.execute_action(Action::MoveCursor(Direction::Down)),
            "Not equal in action result (move 0)."
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 0)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 0)."
        );

        // undo
        assert_eq!(
            Err(EditErr::NoChangesToUndo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result (move 1)"
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 1)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 1)."
        );
    }

    #[test]
    fn root_redo() {
        let start_tree = TestJson::Array(vec![]);
        let end_tree = TestJson::Object(vec![]);

        let arena: Arena<Json> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = Dag::new(&arena, root, Path::root());

        assert_eq!(
            Ok(EditSuccess::Replace(Class::Object)),
            editable_tree.execute_action(Action::Replace(Insertable::CountedNode(1, 'o'))),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // undo
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // redo
        assert_eq!(
            Ok(EditSuccess::Redo),
            editable_tree.execute_action(Action::Redo),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        //Dag level == 1
        let start_tree = TestJson::Array(vec![TestJson::Null, TestJson::True, TestJson::False]);
        let start_cursor_location = Path::root();
        let end_cursor_location = Path::from_vec(vec![0]);

        // Initialise a Dag with the cursor at the root
        let arena: Arena<Json> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = Dag::new(&arena, root, start_cursor_location);

        assert_eq!(
            Ok(EditSuccess::Move(Direction::Down)),
            editable_tree.execute_action(Action::MoveCursor(Direction::Down)),
            "Not equal in action result (move 0)."
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 0)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 0)."
        );

        // undo
        assert_eq!(
            Err(EditErr::NoChangesToUndo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result (move 1)."
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 1)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 1). "
        );

        // redo
        assert_eq!(
            Err(EditErr::NoChangesToRedo),
            editable_tree.execute_action(Action::Redo),
            "Not equal in action result (move 2)."
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Not equal in tree (move 2)."
        );
        assert_eq!(
            end_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location (move 2)."
        );
    }

    #[test]
    fn level_1_insertchild() {
        run_test_ok(
            TestJson::Array(vec![TestJson::Array(vec![]), TestJson::True]),
            Path::from_vec(vec![0]),
            Action::InsertChild(Insertable::CountedNode(1, 'f')),
            EditSuccess::InsertChild(Class::False),
            TestJson::Array(vec![TestJson::Array(vec![TestJson::False]), TestJson::True]),
            Path::from_vec(vec![0, 0]),
        );
    }

    #[test]
    fn level_1_insertafter() {
        run_test_ok(
            TestJson::Array(vec![TestJson::True, TestJson::True]),
            Path::from_vec(vec![1]),
            Action::InsertAfter(Insertable::CountedNode(1, 'f')),
            EditSuccess::InsertNextToCursor {
                side: Side::Next,
                class: Class::False,
            },
            TestJson::Array(vec![TestJson::True, TestJson::True, TestJson::False]),
            Path::from_vec(vec![2]),
        );

        // Dag level == 2
        run_test_ok(
            TestJson::Array(vec![
                TestJson::Array(vec![TestJson::Null, TestJson::True]),
                TestJson::Object(vec![("value".to_string(), TestJson::True)]),
            ]),
            Path::from_vec(vec![1]),
            Action::InsertAfter(Insertable::CountedNode(1, 'f')),
            EditSuccess::InsertNextToCursor {
                side: Side::Next,
                class: Class::False,
            },
            TestJson::Array(vec![
                TestJson::Array(vec![TestJson::Null, TestJson::True]),
                TestJson::Object(vec![("value".to_string(), TestJson::True)]),
                TestJson::False,
            ]),
            Path::from_vec(vec![2]),
        );
    }

    #[test]
    fn level_1_insertbefore() {
        run_test_ok(
            TestJson::Array(vec![TestJson::Array(vec![]), TestJson::True]),
            Path::from_vec(vec![0]),
            Action::InsertBefore(Insertable::CountedNode(1, 'f')),
            EditSuccess::InsertNextToCursor {
                side: Side::Prev,
                class: Class::False,
            },
            TestJson::Array(vec![
                TestJson::False,
                TestJson::Array(vec![]),
                TestJson::True,
            ]),
            Path::from_vec(vec![0]),
        );

        // Dag level == 2
        run_test_ok(
            TestJson::Array(vec![
                TestJson::Array(vec![TestJson::Null, TestJson::True]),
                TestJson::Object(vec![("value".to_string(), TestJson::True)]),
            ]),
            Path::from_vec(vec![1]),
            Action::InsertBefore(Insertable::CountedNode(1, 'f')),
            EditSuccess::InsertNextToCursor {
                side: Side::Prev,
                class: Class::False,
            },
            TestJson::Array(vec![
                TestJson::Array(vec![TestJson::Null, TestJson::True]),
                TestJson::False,
                TestJson::Object(vec![("value".to_string(), TestJson::True)]),
            ]),
            Path::from_vec(vec![1]),
        );
    }

    #[test]
    fn level_1_delete() {
        run_test_ok(
            TestJson::Array(vec![TestJson::True, TestJson::Array(vec![])]),
            Path::from_vec(vec![1]),
            Action::Delete,
            EditSuccess::Delete {
                name: "array".to_string(),
            },
            TestJson::Array(vec![TestJson::True]),
            Path::from_vec(vec![0]),
        );

        run_test_ok(
            TestJson::Array(vec![TestJson::True]),
            Path::from_vec(vec![0]),
            Action::Delete,
            EditSuccess::Delete {
                name: "true".to_string(),
            },
            TestJson::Array(vec![]),
            Path::root(),
        );
    }

    #[test]
    fn level_1_replace() {
        run_test_ok(
            TestJson::Array(vec![TestJson::True, TestJson::Array(vec![])]),
            Path::from_vec(vec![1]),
            Action::Replace(Insertable::CountedNode(1, 'n')),
            EditSuccess::Replace(Class::Null),
            TestJson::Array(vec![TestJson::True, TestJson::Null]),
            Path::from_vec(vec![1]),
        );

        run_test_ok(
            TestJson::Object(vec![
                ("key-1".to_string(), TestJson::False),
                ("key-2".to_string(), TestJson::True),
            ]),
            Path::from_vec(vec![1, 1]),
            Action::Replace(Insertable::CountedNode(1, 'n')),
            EditSuccess::Replace(Class::Null),
            TestJson::Object(vec![
                ("key-1".to_string(), TestJson::False),
                ("key-2".to_string(), TestJson::Null),
            ]),
            Path::from_vec(vec![1, 1]),
        );

        run_test_err(
            TestJson::Object(vec![
                ("key-1".to_string(), TestJson::False),
                ("key-2".to_string(), TestJson::True),
            ]),
            Path::from_vec(vec![1, 0]),
            Action::Replace(Insertable::CountedNode(1, 'n')),
            EditErr::CannotBeChild {
                class: Class::Null,
                parent_name: ("field".to_string()),
            },
        );
    }

    #[test]
    fn level_1_movecursor() {
        run_test_ok(
            TestJson::Array(vec![TestJson::True, TestJson::Object(vec![])]),
            Path::root(),
            Action::MoveCursor(Direction::Down),
            EditSuccess::Move(Direction::Down),
            TestJson::Array(vec![TestJson::True, TestJson::Object(vec![])]),
            Path::from_vec(vec![0]),
        );
    }

    #[test]
    fn level_1_undo_and_redo() {
        // The original snapshot of the tree
        let start_tree = TestJson::Array(vec![TestJson::Null, TestJson::True, TestJson::False]);
        let end_tree = TestJson::False;

        // Create and initialise Dag to test
        let arena: Arena<Json> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let mut editable_tree = Dag::new(&arena, root, Path::root());

        // Step 1: Replace root with `false`
        println!("Inserting `false`");
        assert_eq!(
            Ok(EditSuccess::Replace(Class::False)),
            editable_tree.execute_action(Action::Replace(Insertable::CountedNode(1, 'f'))),
            "Not equal in action result."
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Perform one undo.  This be successful, because it's undoing the replace-with-false
        println!("Performing first undo");
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Perform another undo.  This won't be successful, because there's nothing to undo
        println!("Performing the 2nd undo");
        assert_eq!(
            Err(EditErr::NoChangesToUndo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(
            start_tree,
            editable_tree.root(),
            "Failed undo modified the tree"
        );
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Failed undo moved the cursor"
        );

        // Redo the change we undid (this should succeed)
        println!("Performing the 1st redo");
        assert_eq!(
            Ok(EditSuccess::Redo),
            editable_tree.execute_action(Action::Redo),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Redo another time, but there are no changes to redo
        println!("Performing the 2nd redo");
        assert_eq!(
            Err(EditErr::NoChangesToRedo),
            editable_tree.execute_action(Action::Redo),
            "Not equal in action result"
        );
        assert_eq!(end_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    #[test]
    #[ignore]
    // This is the test cases for issue 27
    fn level_2_undo() {
        // The original snapshot of the tree

        let start_tree = TestJson::Array(vec![
            TestJson::Null,
            TestJson::Object(vec![("key".to_string(), TestJson::True)]),
            TestJson::False,
        ]);

        let expected_tree = TestJson::Array(vec![
            TestJson::Null,
            TestJson::Object(vec![]),
            TestJson::False,
        ]);

        // Create and initialise Dag to test
        let arena: Arena<Json> = Arena::new();
        let root = start_tree.add_to_arena(&arena);
        let start_cursor_location = Path::from_vec(vec![1, 0]);
        let expected_cursor_location = Path::from_vec(vec![1]);
        let mut editable_tree = Dag::new(&arena, root, start_cursor_location);

        // Step 1: Delete TestJson::object's child
        println!("Delete `key-value` pair");
        assert_eq!(
            Ok(EditSuccess::Delete {
                name: "field".to_string()
            }),
            editable_tree.execute_action(Action::Delete),
            "Not equal in action result."
        );
        assert_eq!(expected_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            expected_cursor_location, editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );

        // Perform one undo.
        println!("Performing undo");
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo),
            "Not equal in action result"
        );
        assert_eq!(start_tree, editable_tree.root(), "Not equal in tree.");
        assert_eq!(
            Path::root(),
            editable_tree.current_cursor_path,
            "Not equal in cursor location."
        );
    }

    /// This is a regression test for issue #51 (fixed in PR #53), where Sapling crashes if:
    /// 1. The user deletes the cursor when the cursor is the last child of its parent
    /// 2. The user undoes this edit
    /// 3. The user redoes this edit
    #[test]
    fn delete_cursor_crash_bug() {
        // Create and initialise Dag to test (start with Json `[null]` with the cursor selecting
        // the `null`)
        let arena: Arena<Json> = Arena::new();
        let root = TestJson::Array(vec![TestJson::Null]).add_to_arena(&arena);
        let mut editable_tree = Dag::new(&arena, root, Path::from_vec(vec![0]));

        // Delete the node under the cursor, causing the cursor to move to the root
        assert_eq!(
            Ok(EditSuccess::Delete {
                name: "null".to_string()
            }),
            editable_tree.execute_action(Action::Delete)
        );
        assert_eq!(editable_tree.current_cursor_path, Path::root());

        // Undo this change, causing the cursor to move back to `null`
        assert_eq!(
            Ok(EditSuccess::Undo),
            editable_tree.execute_action(Action::Undo)
        );

        // Redo the change.  It's not really important what the tree is here, so long as the Dag
        // doesn't panic when the cursor is generated
        assert_eq!(
            Ok(EditSuccess::Redo),
            editable_tree.execute_action(Action::Redo)
        );

        let _cursor = editable_tree.cursor();
    }

    /// This is a regression test for issue #68, where Sapling crashes if an invalid char is used
    /// to insert into any node
    #[test]
    fn invalid_insert_crash() {
        // Create and initialise Dag to test (start with JSON `[null]` with the cursor selecting
        // the `null`)
        let arena: Arena<Json> = Arena::new();
        let root = TestJson::Array(vec![TestJson::Null]).add_to_arena(&arena);
        let mut editable_tree = Dag::new(&arena, root, Path::root());

        // Inserting an invalid char into the array should error gracefully
        assert_eq!(
            Err(EditErr::CharNotANode('x')),
            editable_tree.execute_action(Action::InsertChild(Insertable::CountedNode(1, 'x')))
        );

        // Move the cursor to the 'null'
        assert_eq!(
            Ok(EditSuccess::Move(Direction::Down)),
            editable_tree.move_cursor(Direction::Down)
        );

        // Inserting an invalid char into the array should error gracefully
        assert_eq!(
            Err(EditErr::CharNotANode('x')),
            editable_tree.execute_action(Action::InsertChild(Insertable::CountedNode(1, 'x')))
        );
    }

    /// This is a regression test for issue #68, where Sapling crashes if an invalid char is used
    /// to insert into any node
    #[test]
    fn invalid_replace_crash() {
        // Create and initialise Dag to test (start with JSON `[null]` with the cursor selecting
        // the `null`)
        let arena: Arena<Json> = Arena::new();
        let root = TestJson::Array(vec![TestJson::Null]).add_to_arena(&arena);
        let mut editable_tree = Dag::new(&arena, root, Path::root());

        // Inserting an invalid char into the array should error gracefully
        assert_eq!(
            Err(EditErr::CharNotANode('x')),
            editable_tree.execute_action(Action::Replace(Insertable::CountedNode(1, 'x')))
        );

        // Move the cursor to the 'null'
        assert_eq!(
            Ok(EditSuccess::Move(Direction::Down)),
            editable_tree.move_cursor(Direction::Down)
        );

        // Inserting an invalid char into the array should error gracefully
        assert_eq!(
            Err(EditErr::CharNotANode('x')),
            editable_tree.execute_action(Action::Replace(Insertable::CountedNode(1, 'x')))
        );
    }

    /// This is a regression test for issue #78, where directly replacing a field results in an
    /// invalid tree.
    #[test]
    #[ignore]
    fn incorrect_field_replace() {
        run_test_ok(
            // We are selecting the field, not the contained value
            TestJson::Object(vec![("key".to_owned(), TestJson::True)]),
            Path::from_vec(vec![0]),
            Action::Replace(Insertable::CountedNode(1, 'f')),
            EditSuccess::Replace(Class::False),
            // We'd **expect** a new field to implicitly be created, but that is not the case.
            // Instead the resulting JSON will be `{false}`, which is invalid
            TestJson::Object(vec![("".to_owned(), TestJson::False)]),
            Path::from_vec(vec![0]),
        );
    }
}
